---
title: "Abu Dhabi pilot RNA data"
author: "Katie Burnham"
date: '`r Sys.Date()`'
output: html_document
editor_options: 
  chunk_output_type: console
---

Explanatory text and protocol largely from
(http://www.bioconductor.org/help/workflows/rnaseqGene/)[http://www.bioconductor.org/help/workflows/rnaseqGene/],
'Count-based differential expression analysis of RNA sequencing data using R and
Bioconductor - Anders et al', and the DESeq2 manual.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(kburnhamfunctions)
# install.packages("Vennerable", repos = "http://R-Forge.R-project.org")

# Vennerable needs graph and RBGL, from bioconductor repository
# source("http://bioconductor.org/biocLite.R")
# biocLite("graph")
# biocLite("RBGL")

# Those packages also need reshape and gtools
library(reshape)
library(gtools)
library(Vennerable)

# Differential expressino analysis
library(DESeq2)

# plotting figures
library(dplyr)
library(ggplot2)
library(ggrepel)
library(gridExtra)

# normalisation
library(vsn)

# heatmap
library(pheatmap)
library(RColorBrewer)

# parallel computing
library(BiocParallel)
register(SnowParam(4))

# experimental report generation
library(ReportingTools)

# look up gene ids
library(biomaRt)

# pathway analysis
library(XGR)
```

##  Input Data

The feature count matrix prepared using the CountMatrix.R script is read in, along
with sample information. The value in the i-th row and the j-th column of the 
matrix tells how many reads (or fragments, for paired-end RNA-seq) have been
assigned to gene i in sample j. 

These are not pre-normalized for sequencing depth/library size, as DESeq2's
statistical model is most powerful when applied to un-normalized counts, and is
designed to account for library size differences internally.

```{r data}
counts <- read.delim("U:/Abu-Dhabi/RNASeq/PilotData/PilotRNA-hisat-count-data.txt")
full.s.info <- read.delim("U:/Abu-Dhabi/RNASeq/PilotData/PilotSampleInfoExpanded.txt",
                          stringsAsFactors=F, row.names=1)
full.s.info$PatientNumber <- as.character(full.s.info$PatientNumber)

# check order of samples
all(colnames(counts) == rownames(full.s.info))
```

DESeq2 uses the DESeqDataSet object class to store the read counts and the 
intermediate estimated quantities. This has range-base functionality, allowing 
for easier integration with e.g. ChIP-seq peaks. This object must have an
associated design formula expressing the variables used in modelling. This is 
used to estimate the dispersions and log2 FC, and can be changed later if all the
DE steps are subsequently repeated. These data are therefore converted into a
DESeq2 dataset with the sample type and disease status included in the model to
begin with.

NB - under default settings, the final term in the model is the variable of 
interest and control level is first.

```{r convert-to-DESeq2DataSet}
dds <- DESeqDataSetFromMatrix(countData=counts,
                              colData=full.s.info,
                              design= ~ SampleType + Disease)
dds$Disease <- relevel(dds$Disease, ref = "Control")
dds
```

The gene symbols are looked up using biomaRt from their ensembl IDs.

```{r genes}
ensembl <- useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl",
                      GRCh="37")
genes <- getBM(attributes=c('ensembl_gene_id', 
                            'ensembl_transcript_id',
                            'hgnc_symbol', 
                            'chromosome_name', 
                            'start_position',
                            'end_position'), 
                   filters = 'ensembl_gene_id', 
                   values =rownames(counts),
                   mart = ensembl)

featureData <- data.frame(Ensembl=rownames(counts), 
                          Gene=genes$hgnc_symbol[match(rownames(counts),
                                                       genes$ensembl_gene_id)])
mcols(dds) <- DataFrame(mcols(dds), featureData)
mcols(dds)
```

### Pre-filtering

While it is not necessary to pre-filter low count genes before running the DESeq2 
functions, by removing rows in which there are very few reads, we reduce the 
memory size of the dds data object, and we increase the speed of the 
transformation and testing functions. Here we perform a minimal pre-filtering to
keep only rows that have at least 10 reads total (i.e. 5% of samples). Note that
more strict filtering to increase power can be applied via independent filtering 
on the mean of normalized counts within the results function.

```{r pre-filtering}
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep,]
dds
# 35886 208
```

### Exploratory analysis and visualisation

Many common statistical methods for exploratory analysis of multidimensional data,
for example clustering and principal components analysis (PCA), work best for data
that generally has the same range of variance at different ranges of the mean
values. When the expected amount of variance is approximately the same across
different mean values, the data is said to be homoskedastic. For RNA-seq counts,
however, the expected variance grows with the mean. For example, if one performs
PCA directly on a matrix of counts or normalized counts (e.g. correcting for
differences in sequencing depth), the resulting plot typically depends mostly on
the genes with highest counts because they show the largest absolute differences
between samples. A simple and often used strategy to avoid this is to take the
logarithm of the normalized count values plus a pseudocount of 1; however,
depending on the choice of pseudocount, now the genes with the very lowest counts
will contribute a great deal of noise to the resulting plot, because taking the
logarithm of small counts actually inflates their variance. 

As a solution, DESeq2 offers two transformations for count data that stabilize the
variance across the mean: the regularized-logarithm transformation or rlog (Love,
Huber, and Anders 2014), and the variance stabilizing transformation (VST) for
negative binomial data with a dispersion-mean trend (Anders and Huber 2010),
implemented in the vst function. For genes with high counts, the rlog and VST will
give similar results to the ordinary log2 transformation of normalized counts. For
genes with lower counts, however, the values are shrunken towards the genesâ€™
averages across all samples. The rlog-transformed or VST data then becomes
approximately homoskedastic, and can be used directly for computing distances
between samples, making PCA plots, or as input to downstream methods which perform
best with homoskedastic data.

The rlog tends to work well on small datasets (n <30), sometimes outperforming the
VST when there is a large range of sequencing depth across samples (an order of
magnitude difference). The VST is much faster to compute and is less sensitive to
high count outliers than the rlog, so is therefore recommended for large datasets
(hundreds of samples).

On this advice, I have used the VST (this also includes correction for sequencing
depth). The "blind"=TRUE argument means that the experimental design is not used 
to estimate global variability in the counts i.e. more appropriate for QC purposes.

These plots show the relationship between mean expression and sd before and after
normalisation.

```{r vst}
vsd <- vst(dds, blind=TRUE)

# Compare before and after
meanSdPlot(assay(dds))
meanSdPlot(assay(vsd))
```

PCA is then used to explore the relationship between the samples. 

```{r pca}
pcaData <- plotPCA(vsd, intgroup = c("Disease", "SampleType"), returnData = TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))
ggplot(pcaData, aes(x = PC1, y = PC2, color = SampleType, shape = Disease)) +
  geom_point(size =3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed() +
  theme_bw()
```

This shows that a large proportion of the variance 
(`r paste0(percentVar[1], "% variance")`) is explained by PC1, which separates 
the naive and treated cells and also the CD14 cells from the other cell types.

A second PCA for just cultured (and treated) CD14s shows the general separation
between LPS treated cells and non-LPS treated. However, there are a few samples
that don't fall within treatment clusters, and this seems to relate to the patient
number e.g. Patient 100 samples are swapped round, 115 all cluster together in the
centre and 148 at the bottom left. This can be seen in the line plot of PC1, where
the majority of individuals show the same pattern across treatments but some 
clearly differ.

```{r pca-treated}
vsd.treat <- vsd[, vsd$SampleType %in% c("CD14_PBS", "CD14_LPS", 
                                         "CD14_MET", "CD14_MET_LPS")]
vsd.treat$SampleType <- droplevels(vsd.treat$SampleType)
pcaData <- plotPCA(vsd.treat, 
                   intgroup = c("Disease", "SampleType", "PatientNumber", 
                                "SampleNumber", "Repeat.Sample"), 
                   returnData = TRUE)
percentVar <- round(100 * attr(pcaData, "percentVar"))

ggplot(pcaData, aes(x = PC1, y = PC2, color = SampleType, shape = Disease)) +
  geom_point(size =3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed() +
  theme_bw()

ggplot(pcaData, aes(x = PC1, y = PC2, color = SampleType, shape = Disease)) +
  geom_point(size =3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  coord_fixed() +
  geom_text_repel(data=pcaData[pcaData$PatientNumber %in% 
                                 c(94, 100, 102, 115, 148), ], 
                               aes(label=SampleNumber)) +
  theme_bw()

ggplot(pcaData, aes(x=SampleType, y=PC1, col=PatientNumber, group=SampleNumber, 
                    shape=Repeat.Sample)) +
  geom_line() +
  geom_point() +
  theme_bw()
```

This is also seen by clustering the distance matrix:

```{r corr-matrix, fig.height=15}
sampleDists <- dist(t(assay(vsd)))
sampleDistMatrix <- as.matrix(sampleDists)
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
annotation_row=data.frame(vsd@colData@listData[c("Disease", "SampleType")])
rownames(annotation_row) <- rownames(sampleDistMatrix)

pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         annotation_row=annotation_row,
         col = colors)

sampleDists <- dist(t(assay(vsd.treat)))
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- vsd.treat$SampleNameFull
colnames(sampleDistMatrix) <- NULL
annotation_row=data.frame(vsd.treat@colData@listData[c("Disease", "SampleType")])
rownames(annotation_row) <- rownames(sampleDistMatrix)

pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         annotation_row=annotation_row,
         col = colors)
```

## Differential expression analysis

There are many possible comparisons to perform here, and the experimental design 
is complex (different cell types from the same patients and controls and multiple
time points). Contrasts of interest discussed are:

-	LPS response and the overlap with the same in healthy volunteers

-	Modifier effect of MET (CD14 LPS vs PBS vs MET_LPS)

-	T2D vs control on all cell types

-	2nd visit (post MET treatment)

- CD14 vs CD8

- PBMC vs Paxgene

Possible modifiers: 

- Age

- BMI

### LPS response

This is comparing the CD14 cells treated with LPS to those treated with PBS 
(controls), taking account of patient (and excluding the 2nd visit samples). The
log2 FCs are moderated using a normal prior distribution centered on zero and 
scaled to fit the data. This removes noise from low count genes and removes the
need to apply an arbitrary fold change threshold.

P values for specific genes can be zero if all samples have zero counts, if a
sample has an extreme count outlier based on Cook's distance, and if there is a 
low mean normalised count (independent filtering). These genes are removed from 
the results table. Independent filtering is performed based on the mean of
normalised counts for each gene. A threshold is found that optimises the number 
of adjusted p values lower than the significance level alpha. This optimisation
is visualised.

```{r lps-response}
# design
lps.dds <- dds[, dds@colData@listData$SampleType %in% c("CD14_PBS", "CD14_LPS")]
lps.dds <- lps.dds[, lps.dds@colData@listData$Repeat.Sample == FALSE]
# 38 samples remaining (19 individuals, 2 samples each)
lps.dds$SampleType <- droplevels(lps.dds$SampleType)
lps.dds$SampleType <- relevel(lps.dds$SampleType, ref = "CD14_PBS")
lps.dds$PatientNumber <- as.factor(lps.dds$PatientNumber)

design(lps.dds) <- ~ PatientNumber + SampleType
table(lps.dds$SampleType)

# analysis
lps.dds <- DESeq(lps.dds, parallel=TRUE)

# normalised counts
lps.dds.norm <- counts(lps.dds, normalized=TRUE)

# results
lps.res <- results(lps.dds, parallel=TRUE, 
                   # lfcThreshold=log(1.5, 2), altHypothesis="greaterAbs",
                   independentFiltering=TRUE, alpha=0.05)
lps.res$Gene <- mcols(lps.dds)$Gene

plot(metadata(lps.res)$filterNumRej,
     type="b", ylab="Number of rejections",
     xlab="Quantiles of filter", pch=16)
lines(metadata(lps.res)$lo.fit, col="red")
abline(v=metadata(lps.res)$filterTheta)

lps.res.LFC <- lfcShrink(lps.dds, coef=20, parallel=TRUE)
lps.res$log2FoldChange <- lps.res.LFC$log2FoldChange
lps.res$lfcSE <- lps.res.LFC$lfcSE
lpsresOrdered <- lps.res[order(lps.res$padj), ]
lpsresOrdered <- lpsresOrdered[(complete.cases(lpsresOrdered)), ]
lpsresOrdered
summary(lpsresOrdered)
res05 <- results(lps.dds, alpha=0.05)

# write.table(lpsresOrdered,
            # file="U:/Abu-Dhabi/RNASeq/PilotData/LPSResponse_All_Patients.txt",
            # sep="\t")
```

`r sum(lpsresOrdered$padj < 0.05, na.rm=TRUE)` transcripts are differentially
expressed at FDR <0.05. 

Various plots are used for QC. The dispersion estimates are typical, with the 
final estimates shrunk from the gene-wise estimates towards the fitted estimates.

```{r lps-response-plots}
# QC plots
r.lfc <- range(lps.res.LFC$log2FoldChange, na.rm=TRUE)
plotMA(lps.res.LFC, ylim=r.lfc)
abline(h=c(-log(1.5, 2), log(1.5, 2)), col="dodgerblue", lwd=2)

plotDispEsts(lps.dds, main="Dispersion plot")

boxplot(log10(assays(lps.dds)[["cooks"]]), range=0, las=2)
# No outliers 

hist(lps.res$pvalue, breaks=100)

# Top DE genes
top.10 <- order(lps.res$padj)[1:10]
de.plot.list <- list()
for(j in 1:10){
  i <- top.10[j]
  d <- plotCounts(lps.dds, gene=i, 
                intgroup=c("SampleType", "Disease", "PatientNumber"),
                returnData=TRUE)
  gene.name <- as.character(mcols(lps.dds)$Gene[i])
  de.plot.list[[j]] <- ggplot(d, aes(x=SampleType, y=count, color=Disease,
                                     group=PatientNumber)) + 
    geom_point(size=3) + 
    scale_y_log10() +
    theme_bw() +
    geom_line() +
    ylab(gene.name)
}

grid.arrange(grobs=de.plot.list, ncol=2)

lpsresOrdered$sig <- ifelse((lpsresOrdered$padj < 0.05 & 
                            abs(lpsresOrdered$log2FoldChange) >= log(1.5, 2)), 
                          "Sig DE", "Not Sig")
ggplot(data.frame(lpsresOrdered), aes(log2FoldChange, -log10(padj))) +
  geom_point(aes(col=sig)) +
  scale_color_manual(values=c("grey", "red")) +
  theme_bw() +
  geom_text_repel(data=subset(data.frame(lpsresOrdered), padj<5e-10),
                  aes(label=Gene))
```

Pathway analysis of the differentially expressed genes is performed with XGR

```{r lps-xgr}
RData.location <- "http://galahad.well.ox.ac.uk/bigdata"

# All pilot data
data <- unique(as.character(lpsresOrdered$Gene[lpsresOrdered$sig == "Sig DE"]))
background <- unique(as.character(lpsresOrdered$Gene))
eTerm_LPSAll_GOBP_lea <- xEnricherGenes(data=data, background=background,
                                        ontology="GOBP",
                                        ontology.algorithm="lea",
                                        RData.location=RData.location)
bp_LPSAll_GOBP_lea <- xEnrichBarplot(eTerm_LPSAll_GOBP_lea,
                                   displayBy="fdr", top_num=10)
bp_LPSAll_GOBP_lea
```

In order to test for an effect of disease status on the LPS response, the sample
information must be recoded as described in the DESeq2 manual. Briefly, the model
is not full rank when accounting for individual, as each individual is either in
the disease or control group. Individual is recoded within each group, levels 
without samples removed from the design matrix, and the LPS response in disease
and controls contrasted to test if the treatment effect is different across 
groups. 

```{r lps-response-disease}
# to account for the effect of disease status
# two disease status groups with distinct individuals
tmp <- cbind(lps.dds$Disease, lps.dds$PatientNumber)
# 10 patients in control, 9 in disease
# update disease to 1:9 and control 1:10
ind.n <- tmp[, 2]
ind.n[which(tmp[, 1] == 1)] <- as.numeric(as.factor(ind.n[which(tmp[, 1] == 1)]))
ind.n[which(tmp[, 1] == 2)] <- as.numeric(as.factor(ind.n[which(tmp[, 1] == 2)]))

lps.dds.dis <- lps.dds
lps.dds.dis$ind.n <- as.factor(as.character(ind.n))

design(lps.dds.dis) <- ~ Disease + Disease:ind.n + Disease:SampleType
m1 <- model.matrix(design(lps.dds.dis), lps.dds.dis@colData)
all.zero <- apply(m1, 2, function(x) all(x==0))
idx <- which(all.zero)
m1 <- m1[, -idx]
unname(m1)

# analysis
lps.dds.dis <- DESeq(lps.dds.dis, parallel=TRUE, full=m1, betaPrior=FALSE)

# results
lps.dis.res <- results(lps.dds.dis, parallel=TRUE, 
                   # lfcThreshold=log(1.5, 2), altHypothesis="greaterAbs",
                   independentFiltering=TRUE, alpha=0.05,
                   contrast=list("DiseaseT2D.SampleTypeCD14_LPS",
                                 "DiseaseControl.SampleTypeCD14_LPS"))

lps.dis.res <- lps.dis.res[(complete.cases(lps.dis.res)), ]
summary(lps.dis.res)
```

There are no significant genes detected. 

### Comparison to healthy volunteers

These results are positively correlated with the CD14 LPS response from Ben's
healthy volunteer data.

Due to the different platforms used, for this comparison mean log fold changes 
were calculated for each gene.

```{r lps2-correlation}
correlation.plot <- function (limma.1, limma.2, name.1 = "A", name.2 = "B", 
          main.title = "Correlation Plot", 
          key = TRUE, col.1 = "darkgreen", col.2 = "gold", col.both = "blue", 
  labels = FALSE) {
  
  limma.1 <- limma.1[complete.cases(limma.1), ]
  limma.2 <- limma.2[complete.cases(limma.2), ]
  
  limma.2 <- limma.2[which(limma.2$Gene %in% limma.1$Gene), 
    ]
  limma.1 <- limma.1[which(limma.1$Gene %in% limma.2$Gene), 
    ]
  limma.2 <- limma.2[match(limma.1$Gene, limma.2$Gene), 
    ]
  
  plot.range.x <- max(abs(c(limma.1$log2FoldChange)))
  plot.range.y <- max(abs(c(limma.2$log2FoldChange)))
  
  corr.plot.colours <- rep("gray", nrow(limma.1))
  for (i in 1:nrow(limma.1)) {
    if (abs(limma.1$log2FoldChange[i]) > log2(1.5) & 
        limma.1$padj[i] < 0.05 & 
        abs(limma.2$log2FoldChange[i]) > log2(1.5) & 
        limma.2$pad[i] < 0.05) {
      corr.plot.colours[i] <- col.both
    }
    else if ((abs(limma.1$log2FoldChange[i]) > log2(1.5) & 
              limma.1$padj[i] < 0.05) & 
             (abs(limma.2$log2FoldChange[i]) < log2(1.5) | limma.2$padj[i] > 0.05))
      {
      corr.plot.colours[i] <- col.1
    }
    else if ((abs(limma.1$log2FoldChange[i]) < log2(1.5) | 
              limma.1$padj[i] > 0.05) & 
             (abs(limma.2$log2FoldChange[i]) > log2(1.5) & limma.2$padj[i] < 0.05))
      {
      corr.plot.colours[i] <- col.2
    }
    if (limma.1$log2FoldChange[i] * limma.2$log2FoldChange[i] < 0) {
      if (abs(limma.1$log2FoldChange[i]) > log2(1.5) & limma.1$padj[i] < 0.05 &
          abs(limma.2$log2FoldChange[i]) > log2(1.5) & limma.2$padj[i] < 0.05) 
        {
        corr.plot.colours[i] <- "red"
      }
    }
  }
  
  plot(limma.1$log2FoldChange, limma.2$log2FoldChange, 
       xlab = paste("Log2 Fold Change", name.1), 
       ylab = paste("Log2 Fold Change", name.2), 
       main = main.title, 
       xlim = c(-plot.range.x, plot.range.x), 
       ylim = c(-plot.range.y, plot.range.y), 
       col = corr.plot.colours, pch = 20)
  
  text(x = (plot.range.x - 1), y = -(plot.range.y - 1), paste("Pearson's r =", 
    format(cor(limma.1$log2FoldChange, limma.2$log2FoldChange), digits = 3)))
  corr.test <- cor.test(limma.1$log2FoldChange, limma.2$log2FoldChange)
  if (as.numeric(corr.test$p.value) > 0) {
    text(x = (plot.range.x - 1), y = -(plot.range.y - 0.7), 
      paste("p =", format(corr.test$p.value, digits = 3)))
  }
  else {
    text(x = (plot.range.x - 1), y = -(plot.range.y - 0.7), 
      "P < 2.2 x 10-16")
  }
  if (key == TRUE) {
    legend("topleft", c("DE in Both", paste("DE in", name.1), 
      paste("DE in", name.2), "DE in Opposite Directions", 
      "Not DE"), bty = "n", col = c(col.both, col.1, col.2, 
      "red", "gray"), pch = rep(20, 4))
  }
  abline(h = 0)
  abline(v = 0)
  if (labels == TRUE) {
    text(limma.2$Gene, x = limma.1$log2FoldChange, 
         y = limma.2$log2FoldChange + 0.1, cex = 0.8)
  }
}

fairfax <- read.delim("U:/Abu-Dhabi/RNASeq/PilotData/FairfaxScienceLPSDE.txt",
                      stringsAsFactors=FALSE)
fairfax.lps <- fairfax[, c("Symbol", "logFC.LPS2.vs.Naive",
                           "adj.P.Val.LPS2.vs.Naive")]
fairfax.lps <- fairfax.lps[complete.cases(fairfax.lps), ]
fairfax.lps$logFC.LPS2.vs.Naive <- (-fairfax.lps$logFC.LPS2.vs.Naive)

fairfax.lps <- aggregate(fairfax.lps[, 2:3], by=list(fairfax.lps$Symbol), FUN=mean)
colnames(fairfax.lps) <- c("Gene", "log2FoldChange", "padj")
lps.de <- aggregate(lpsresOrdered[, c(2, 6, 7)], by=list(lpsresOrdered$Gene),
                    FUN=mean)
lps.de$Gene <- NULL
colnames(lps.de)[1] <- "Gene"
lps.de <- lps.de[complete.cases(lps.de), ]
correlation.plot(lps.de, fairfax.lps, "Pilot", "Fairfax 2h", "LPS Response")
```

```{r lps24-correlation}
fairfax.lps <- fairfax[, c("Symbol", "logFC.LPS24.vs.Naive",
                           "adj.P.Val.LPS24h.vs.Naive")]
fairfax.lps <- fairfax.lps[complete.cases(fairfax.lps), ]
fairfax.lps$logFC.LPS24.vs.Naive <- (-fairfax.lps$logFC.LPS24.vs.Naive)

fairfax.lps <- aggregate(fairfax.lps[, 2:3], by=list(fairfax.lps$Symbol), FUN=mean)
colnames(fairfax.lps) <- c("Gene", "log2FoldChange", "padj")
correlation.plot(lps.de, fairfax.lps, "Pilot", "Fairfax 24h", "LPS Response")
```









I have also analysed the patients and controls separately:

```{r lps-response-controls}
lps.con.dds <- dds[, dds@colData@listData$SampleType %in% c("CD14_PBS",
                                                            "CD14_LPS")]
lps.con.dds <- lps.con.dds[, lps.con.dds@colData@listData$Repeat.Sample == FALSE]
lps.con.dds <- lps.con.dds[, lps.con.dds@colData@listData$Disease == "Control"]
# 20 samples remaining (10 individuals, 2 samples each)
lps.con.dds$SampleType <- droplevels(lps.con.dds$SampleType)
lps.con.dds$Disease <- droplevels(lps.con.dds$Disease)
lps.con.dds$PatientNumber <- as.factor(lps.con.dds$PatientNumber)
lps.con.dds$SampleType <- relevel(lps.con.dds$SampleType, ref="CD14_PBS")
design(lps.con.dds) <- ~ PatientNumber + SampleType

lps.con.dds <- DESeq(lps.con.dds, parallel=TRUE)
plotDispEsts(lps.con.dds, main="Dispersion plot")

lps.con.res <- results(lps.con.dds, parallel=TRUE, independentFiltering=FALSE,
                       tidy=TRUE)

resultsNames(lps.con.dds)
lps.con.res.LFC <- lfcShrink(lps.con.dds, coef=11, parallel=TRUE)
lps.con.res.LFC
summary(lps.res.LFC)

lps.con.res$log2FoldChange <- lps.con.res.LFC$log2FoldChange
lps.con.res$lfcSE <- lps.con.res.LFC$lfcSE
lpsconresOrdered <- lps.con.res[order(lps.con.res$padj), ]

lpsconresOrdered <- lpsconresOrdered[(complete.cases(lpsconresOrdered)), ]
write.table(lpsconresOrdered, file="PilotData_LPSResponse_Control_Patient.txt",
            sep="\t")

boxplot(log10(assays(lps.con.dds)[["cooks"]]), range=0, las=2)

res05 <- results(lps.con.dds, alpha=0.05)
plotMA(lps.con.res.LFC, ylim=c(-3, 4))

d <- plotCounts(lps.con.dds, gene=which.min(lps.con.res$padj), 
                intgroup=c("SampleType", "PatientNumber"),
                returnData=TRUE)
ggplot(d, aes(x=SampleType, y=count, group=PatientNumber)) + 
  geom_point(size=3) + 
  scale_y_log10() +
  theme_bw() +
  geom_line()

fairfax$log2FoldChange <- fairfax$logFC.LPS2.vs.Naive
fairfax$padj <- fairfax$adj.P.Val.LPS2.vs.Naive
fairfax.lps <- fairfax[, c("Gene", "log2FoldChange", "padj")]
fairfax.lps <- fairfax.lps[complete.cases(fairfax.lps), ]

fairfax.lps <- aggregate(fairfax.lps[, 2:3], by=list(fairfax.lps$Gene), FUN=mean)
colnames(fairfax.lps)[1] <- "Gene"

lpsconresOrdered$Gene <- lps.genes$hgnc_symbol[match(lpsconresOrdered$row, 
                                                lps.genes$ensembl_gene_id)]
lps.con.de <- aggregate(lpsconresOrdered[, c(3, 7)], by=list(lpsconresOrdered$Gene),
                    FUN=mean)
colnames(lps.con.de)[1] <- "Gene"

correlation.plot(lps.con.de, fairfax.lps, "Pilot - Controls", "Fairfax 2h", 
                 "LPS Response")
correlation.plot(lps.de, lps.con.de, "Pilot", "Pilot - Controls", "LPS Response")
```


```{r lps-response-t2d}
lps.t2d.dds <- dds[, dds@colData@listData$SampleType %in% c("CD14_PBS",
                                                            "CD14_LPS")]
lps.t2d.dds <- lps.t2d.dds[, lps.t2d.dds@colData@listData$Repeat.Sample == FALSE]
lps.t2d.dds <- lps.t2d.dds[, lps.t2d.dds@colData@listData$Disease == "T2D"]
# 18 samples remaining (9 individuals, 2 samples each)
lps.t2d.dds$SampleType <- droplevels(lps.t2d.dds$SampleType)
lps.t2d.dds$SampleType <- relevel(lps.t2d.dds$SampleType, ref="CD14_PBS")
lps.t2d.dds$Disease <- droplevels(lps.t2d.dds$Disease)
lps.t2d.dds$PatientNumber <- as.factor(lps.t2d.dds$PatientNumber)
design(lps.t2d.dds) <- ~ PatientNumber + SampleType

lps.t2d.dds <- DESeq(lps.t2d.dds, parallel=TRUE)
plotDispEsts(lps.t2d.dds, main="Dispersion plot")

lps.t2d.res <- results(lps.t2d.dds, parallel=TRUE, independentFiltering=FALSE,
                       tidy=TRUE)

resultsNames(lps.t2d.dds)
lps.t2d.res.LFC <- lfcShrink(lps.t2d.dds, coef=10, parallel=TRUE)
lps.t2d.res.LFC
summary(lps.res.LFC)

lps.t2d.res$log2FoldChange <- lps.t2d.res.LFC$log2FoldChange
lps.t2d.res$lfcSE <- lps.t2d.res.LFC$lfcSE
lpst2dresOrdered <- lps.t2d.res[order(lps.t2d.res$padj), ]

lpst2dresOrdered <- lpst2dresOrdered[(complete.cases(lpst2dresOrdered)), ]
write.table(lpst2dresOrdered, file="PilotData_LPSResponse_T2D_Patient.txt",
            sep="\t")

boxplot(log10(assays(lps.t2d.dds)[["cooks"]]), range=0, las=2)

res05 <- results(lps.t2d.dds, alpha=0.05)
plotMA(lps.t2d.res.LFC, ylim=c(-2, 2))

d <- plotCounts(lps.t2d.dds, gene=which.min(lps.t2d.res$padj), 
                intgroup=c("SampleType", "PatientNumber"),
                returnData=TRUE)
ggplot(d, aes(x=SampleType, y=count, group=PatientNumber)) + 
  geom_point(size=3) + 
  scale_y_log10() +
  theme_bw() +
  geom_line()

fairfax$log2FoldChange <- fairfax$logFC.LPS2.vs.Naive
fairfax$padj <- fairfax$adj.P.Val.LPS2.vs.Naive
fairfax.lps <- fairfax[, c("Gene", "log2FoldChange", "padj")]
fairfax.lps <- fairfax.lps[complete.cases(fairfax.lps), ]

fairfax.lps <- aggregate(fairfax.lps[, 2:3], by=list(fairfax.lps$Gene), FUN=mean)
colnames(fairfax.lps)[1] <- "Gene"

lpst2dresOrdered$Gene <- lps.genes$hgnc_symbol[match(lpst2dresOrdered$row, 
                                                lps.genes$ensembl_gene_id)]
lps.t2d.de <- aggregate(lpst2dresOrdered[, c(3, 7)], by=list(lpst2dresOrdered$Gene),
                    FUN=mean)
colnames(lps.t2d.de)[1] <- "Gene"

correlation.plot(lps.t2d.de, fairfax.lps, "Pilot - T2D", "Fairfax 2h", 
                 "LPS Response")
correlation.plot(lps.de, lps.t2d.de, "Pilot", "Pilot - T2D", "LPS Response")
```

Pathway analysis using XGR of LPS response

```{r lps-xgr-hv}
# Fairfax
data <- fairfax$Symbol[fairfax$adj.P.Val.LPS2.vs.Naive < 0.05 &
                         abs(fairfax$logFC.LPS2.vs.Naive) > log(1.5, 2)]
background <- fairfax$Symbol
eTerm_LPS2_GOBP_lea <- xEnricherGenes(data=data, background=background,
                                      ontology="GOBP",
                                      ontology.algorithm="lea",
                                     RData.location=RData.location)

# Compare
list_eTerm <- list(eTerm_LPSAll_GOBP_lea, eTerm_LPS2_GOBP_lea)
names(list_eTerm) <- c('Abu Dhabi', 'Fairfax')
xEnrichCompare(list_eTerm, displayBy="fc", FDR.cutoff=0.01) + 
  theme(axis.text.y=element_text(size=10))

# Controls
data <- lpsconresOrdered$Gene[lpsconresOrdered$pad < 0.05 &
                              abs(lpsconresOrdered$log2FoldChange) > log(1.5, 2)]
background <- lpsconresOrdered$Gene
eTerm_LPSControl_GOBP_lea <- xEnricherGenes(data=data, background=background,
                                          ontology="GOBP",
                                          ontology.algorithm="lea",
                                          RData.location=RData.location)

# T2D
data <- lpst2dresOrdered$Gene[lpst2dresOrdered$padj < 0.05 &
                                abs(lpst2dresOrdered$log2FoldChange) > log(1.5, 2)]
background <- lpst2dresOrdered$Gene
eTerm_LPST2D_GOBP_lea <- xEnricherGenes(data=data, background=background,
                                          ontology="GOBP",
                                          ontology.algorithm="lea",
                                          RData.location=RData.location)

# Compare
list_eTerm <- list(eTerm_LPSAll_GOBP_lea, eTerm_LPSControl_GOBP_lea,
                   eTerm_LPST2D_GOBP_lea)
names(list_eTerm) <- c('Abu Dhabi (All)', 'Controls', "T2D")
xEnrichCompare(list_eTerm, displayBy="fc", FDR.cutoff=0.01) + 
  theme(axis.text.y=element_text(size=10))
```


### Overlap with HV

### Modifier effect of MET


### T2D vs Controls

The repeat samples are excluded, patient is not included in the model (as the
model would not be full rank) but Sample Type is. 

```{r disease}
disease.dds <- dds[, dds@colData@listData$Repeat.Sample == FALSE]
# 152 samples remaining (19 individuals, 8 samples each)
disease.dds$PatientNumber <- as.factor(disease.dds$PatientNumber)
design(disease.dds) <- ~ SampleType + Disease

disease.dds <- DESeq(disease.dds, parallel=TRUE)
plotDispEsts(disease.dds, main="Dispersion plot")

disease.res <- results(disease.dds, parallel=TRUE, independentFiltering=FALSE,
                       tidy=TRUE)

resultsNames(disease.dds)
disease.res.LFC <- lfcShrink(disease.dds, coef=9, parallel=TRUE)
disease.res.LFC
summary(lps.res.LFC)

disease.res$log2FoldChange <- disease.res.LFC$log2FoldChange
disease.res$lfcSE <- disease.res.LFC$lfcSE
diseaseresOrdered <- disease.res[order(disease.res$padj), ]

diseaseresOrdered <- diseaseresOrdered[(complete.cases(diseaseresOrdered)), ]
write.table(diseaseresOrdered, file="PilotData_Disease_SampleType.txt",
            sep="\t")

boxplot(log10(assays(disease.dds)[["cooks"]]), range=0, las=2)

res05 <- results(disease.dds, alpha=0.05)
plotMA(disease.res.LFC, ylim=c(-3, 3))

d <- plotCounts(disease.dds, gene=which.min(disease.res$padj), 
                intgroup=c("Disease", "SampleType", "PatientNumber"),
                returnData=TRUE)
ggplot(d, aes(x=Disease, y=count, group=SampleType, col=SampleType)) + 
  geom_point(size=3) + 
  scale_y_log10() +
  theme_bw() +
  geom_line()

ggplot(d, aes(x=Disease, y=count, group=PatientNumber, col=PatientNumber)) + 
  facet_wrap(~ SampleType, scales="free") +
  geom_point(size=3) + 
  scale_y_log10() +
  theme_bw() +
  geom_line()
```


### Repeat visit

Individuals without a repeat visit are excluded.

```{r repeat}
repeat.inds <- names(which(table(dds$PatientNumber) == 16))
repeat.dds <- dds[, dds@colData@listData$PatientNumber %in% repeat.inds]
# 122 samples remaining (7 individuals, 16 samples each)
repeat.dds$PatientNumber <- as.factor(repeat.dds$PatientNumber)
design(repeat.dds) <- ~ SampleType + PatientNumber + Repeat.Sample

repeat.dds <- DESeq(repeat.dds, parallel=TRUE)
plotDispEsts(repeat.dds, main="Dispersion plot")

repeat.res <- results(repeat.dds, parallel=TRUE, independentFiltering=FALSE,
                       tidy=TRUE)

resultsNames(repeat.dds)
repeat.res.LFC <- lfcShrink(repeat.dds, coef=15, parallel=TRUE)
repeat.res.LFC
summary(lps.res.LFC)

repeat.res$log2FoldChange <- repeat.res.LFC$log2FoldChange
repeat.res$lfcSE <- repeat.res.LFC$lfcSE
repeatresOrdered <- repeat.res[order(repeat.res$padj), ]

repeatresOrdered <- repeatresOrdered[(complete.cases(repeatresOrdered)), ]
write.table(repeatresOrdered, file="PilotData_repeat_SampleType.txt",
            sep="\t")

boxplot(log10(assays(repeat.dds)[["cooks"]]), range=0, las=2)

res05 <- results(repeat.dds, alpha=0.05)
plotMA(repeat.res.LFC, ylim=c(-2, 2))

d <- plotCounts(repeat.dds, gene=repeatresOrdered$row[1], 
                intgroup=c("Repeat.Sample", "SampleType", "PatientNumber"),
                returnData=TRUE)
ggplot(d, aes(x=Repeat.Sample, y=count, group=PatientNumber, col=PatientNumber)) + 
  geom_point(size=3) + 
  scale_y_log10() +
  theme_bw() +
  geom_line()

ggplot(d, aes(x=Repeat.Sample, y=count, group=PatientNumber, col=PatientNumber)) + 
  facet_wrap(~ SampleType, scales="free") +
  geom_point(size=3) + 
  scale_y_log10() +
  theme_bw() +
  geom_line()
```


### CD14 vs CD8

### PBMC vs Paxgene

### Modifying effect of age and BMI